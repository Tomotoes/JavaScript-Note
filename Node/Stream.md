# Stream



## Stream是什么？

Streams 是一个数据集——和数组、字符串一样。

不同的是streams的数据可能不能马上全部获取到，他们不需要在内存中。

这样使得streams在处理大数据集或者来自外部的数据源的数据块上能发挥很大的作用。



然而，streams不仅是能用在大数据上，也给我们在代码中的可组合的能力。

就像通过发送其他较小的Linux命令组成强大的Linux命令一样，我们可以在Node中用streams做同样的事情。

流（stream）在 Node.js 中是处理流数据的抽象接口（abstract interface）。 

stream 模块提供了基础的 API 。使用这些 API 可以很容易地来构建实现流接口的对象。



Node.js 提供了多种流对象。 例如， HTTP 请求 和 process.stdout 就都是流的实例。

流可以是可读的、可写的，或是可读写的。

所有流的对象都是EventEmitter的实例，都实现了EventEmitter的接口。

也就是流具有事件的能力，可以通过发射事件来反馈流的状态。

这样我们就可以注册监听流的事件，来达到我们的目的。

也就是我们订阅了流的事件，这个事件触发时，流会通知我，然后我就可以做相应的操作了。

 

 相比于fs模块，流更适用于读取一个大文件，一次性读取会占用大量内存，效率很低，而流是将数据分割成段，会一段一段的读取，效率会很高。说了一堆，先上概念，一起看看它是谁 



#### 概念

- 流是一组有序的，有起点和终点的字节数据传输手段
- 它不关心文件的整体内容，只关注是否从文件中读到了数据，以及读到数据之后的处理
- 流是一个抽象接口，被 Node 中的很多对象所实现。比如HTTP 服务器request和response对象都是流

node中很多内容都应用到了流，比如http模块的req就是可读流，res是可写流，而socket是可读可写流，看起来屌屌的，那么我们今天就都不讲他们，只来讲一下可读流和可写流这对兄弟

可读流和可写流对文件的操作用的也是fs模块

 

 创建可读流

```js
const fs = require('fs');   // 引入fs核心模块

// fs.createReadStream(path, options)
// 返回的是一个可读流对象
let rs = fs.createReadStream('1.txt', {
    flags: 'r',         // 文件的读取操作，默认是'r':读取
    encoding: 'utf8',   // 设置编码格式，默认是null, null代表的是buffer
    autoClose: true,    // 读取完毕后自动关闭
    highWaterMark: 3,   // 默认是读取64k    64 * 1024字节
    start: 0,
    end: 3              // 文件结束位置索引，和正常的截取slice有所不同，包前又包后(包括自己结束的位置)
});

// 默认情况下，不会将文件中的内容输出
// 内部会先创建一个buffer先读取3字节

// 1.txt文件内容为 123456789
```

 

 

 流动模式会疯狂的触发data事件，直到读取完毕 

 

 